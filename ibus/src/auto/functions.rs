// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /usr/share/gir-1.0
// from ../gir-files
// DO NOT EDIT

use crate::{Attribute,ModifierType};
use glib::{translate::*};
use std::{mem};


#[doc(alias = "ibus_accelerator_name")]
pub fn accelerator_name(accelerator_key: u32, accelerator_mods: ModifierType) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::ibus_accelerator_name(accelerator_key, accelerator_mods.into_glib()))
    }
}

#[cfg(any(feature = "v1_5_18", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_18")))]
#[doc(alias = "ibus_accelerator_parse")]
pub fn accelerator_parse(accelerator: &str) -> (u32, ModifierType) {
    assert_initialized_main_thread!();
    unsafe {
        let mut accelerator_key = mem::MaybeUninit::uninit();
        let mut accelerator_mods = mem::MaybeUninit::uninit();
        ffi::ibus_accelerator_parse(accelerator.to_glib_none().0, accelerator_key.as_mut_ptr(), accelerator_mods.as_mut_ptr());
        (accelerator_key.assume_init(), from_glib(accelerator_mods.assume_init()))
    }
}

#[doc(alias = "ibus_accelerator_valid")]
pub fn accelerator_valid(keyval: u32, modifiers: ModifierType) -> bool {
    assert_initialized_main_thread!();
    unsafe {
        from_glib(ffi::ibus_accelerator_valid(keyval, modifiers.into_glib()))
    }
}

#[doc(alias = "ibus_attr_background_new")]
pub fn attr_background_new(color: u32, start_index: u32, end_index: u32) -> Option<Attribute> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_attr_background_new(color, start_index, end_index))
    }
}

#[doc(alias = "ibus_attr_foreground_new")]
pub fn attr_foreground_new(color: u32, start_index: u32, end_index: u32) -> Option<Attribute> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_attr_foreground_new(color, start_index, end_index))
    }
}

//#[doc(alias = "ibus_emoji_dict_load")]
//pub fn emoji_dict_load(path: &str) -> /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 25 } {
//    unsafe { TODO: call ffi:ibus_emoji_dict_load() }
//}

//#[doc(alias = "ibus_emoji_dict_lookup")]
//pub fn emoji_dict_lookup(dict: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 1, id: 33 }, emoji: &str) -> Option<EmojiData> {
//    unsafe { TODO: call ffi:ibus_emoji_dict_lookup() }
//}

//#[doc(alias = "ibus_emoji_dict_save")]
//pub fn emoji_dict_save(path: &str, dict: /*Unknown conversion*//*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 25 }) {
//    unsafe { TODO: call ffi:ibus_emoji_dict_save() }
//}

#[doc(alias = "ibus_get_address")]
#[doc(alias = "get_address")]
pub fn address() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_get_address())
    }
}

#[doc(alias = "ibus_get_daemon_uid")]
#[doc(alias = "get_daemon_uid")]
pub fn daemon_uid() -> libc::c_long {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_get_daemon_uid()
    }
}

#[doc(alias = "ibus_get_language_name")]
#[doc(alias = "get_language_name")]
pub fn language_name(_locale: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::ibus_get_language_name(_locale.to_glib_none().0))
    }
}

#[doc(alias = "ibus_get_local_machine_id")]
#[doc(alias = "get_local_machine_id")]
pub fn local_machine_id() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_get_local_machine_id())
    }
}

#[doc(alias = "ibus_get_socket_path")]
#[doc(alias = "get_socket_path")]
pub fn socket_path() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_get_socket_path())
    }
}

#[doc(alias = "ibus_get_timeout")]
#[doc(alias = "get_timeout")]
pub fn timeout() -> i32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_get_timeout()
    }
}

#[doc(alias = "ibus_get_untranslated_language_name")]
#[doc(alias = "get_untranslated_language_name")]
pub fn untranslated_language_name(_locale: &str) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::ibus_get_untranslated_language_name(_locale.to_glib_none().0))
    }
}

#[doc(alias = "ibus_get_user_name")]
#[doc(alias = "get_user_name")]
pub fn user_name() -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_get_user_name())
    }
}

#[doc(alias = "ibus_init")]
pub fn init() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_init();
    }
}

#[doc(alias = "ibus_key_event_from_string")]
pub fn key_event_from_string(string: &str) -> Option<(u32, u32)> {
    assert_initialized_main_thread!();
    unsafe {
        let mut keyval = mem::MaybeUninit::uninit();
        let mut modifiers = mem::MaybeUninit::uninit();
        let ret = from_glib(ffi::ibus_key_event_from_string(string.to_glib_none().0, keyval.as_mut_ptr(), modifiers.as_mut_ptr()));
        if ret { Some((keyval.assume_init(), modifiers.assume_init())) } else { None }
    }
}

#[doc(alias = "ibus_key_event_to_string")]
pub fn key_event_to_string(keyval: u32, modifiers: u32) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_full(ffi::ibus_key_event_to_string(keyval, modifiers))
    }
}

#[doc(alias = "ibus_keyval_convert_case")]
pub fn keyval_convert_case(symbol: u32) -> (u32, u32) {
    assert_initialized_main_thread!();
    unsafe {
        let mut lower = mem::MaybeUninit::uninit();
        let mut upper = mem::MaybeUninit::uninit();
        ffi::ibus_keyval_convert_case(symbol, lower.as_mut_ptr(), upper.as_mut_ptr());
        (lower.assume_init(), upper.assume_init())
    }
}

#[doc(alias = "ibus_keyval_from_name")]
pub fn keyval_from_name(keyval_name: &str) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_keyval_from_name(keyval_name.to_glib_none().0)
    }
}

#[doc(alias = "ibus_keyval_name")]
pub fn keyval_name(keyval: u32) -> Option<glib::GString> {
    assert_initialized_main_thread!();
    unsafe {
        from_glib_none(ffi::ibus_keyval_name(keyval))
    }
}

#[doc(alias = "ibus_keyval_to_lower")]
pub fn keyval_to_lower(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_keyval_to_lower(keyval)
    }
}

#[doc(alias = "ibus_keyval_to_unicode")]
pub fn keyval_to_unicode(keyval: u32) -> char {
    assert_initialized_main_thread!();
    unsafe {
        std::convert::TryFrom::try_from(ffi::ibus_keyval_to_unicode(keyval)).expect("conversion from an invalid Unicode value attempted")
    }
}

#[doc(alias = "ibus_keyval_to_upper")]
pub fn keyval_to_upper(keyval: u32) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_keyval_to_upper(keyval)
    }
}

#[doc(alias = "ibus_main")]
pub fn main() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_main();
    }
}

#[doc(alias = "ibus_quit")]
pub fn quit() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_quit();
    }
}

#[doc(alias = "ibus_set_display")]
pub fn set_display(display: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_set_display(display.to_glib_none().0);
    }
}

#[doc(alias = "ibus_set_log_handler")]
pub fn set_log_handler(verbose: bool) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_set_log_handler(verbose.into_glib());
    }
}

#[doc(alias = "ibus_unicode_to_keyval")]
pub fn unicode_to_keyval(wc: char) -> u32 {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_unicode_to_keyval(wc.into_glib())
    }
}

#[doc(alias = "ibus_unset_log_handler")]
pub fn unset_log_handler() {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_unset_log_handler();
    }
}

#[doc(alias = "ibus_write_address")]
pub fn write_address(address: &str) {
    assert_initialized_main_thread!();
    unsafe {
        ffi::ibus_write_address(address.to_glib_none().0);
    }
}
