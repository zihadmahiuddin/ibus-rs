// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /usr/share/gir-1.0
// from ../gir-files
// DO NOT EDIT

use crate::{Object,Serializable,XEventType};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,fmt,mem::transmute};

glib::wrapper! {
    #[doc(alias = "IBusXEvent")]
    pub struct XEvent(Object<ffi::IBusXEvent, ffi::IBusXEventClass>) @extends Serializable, Object;

    match fn {
        type_ => || ffi::ibus_x_event_get_type(),
    }
}

impl XEvent {
        pub const NONE: Option<&'static XEvent> = None;
    

    //#[doc(alias = "ibus_x_event_new")]
    //pub fn new(first_property_name: &str, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) -> XEvent {
    //    unsafe { TODO: call ffi:ibus_x_event_new() }
    //}

            // rustdoc-stripper-ignore-next
            /// Creates a new builder-pattern struct instance to construct [`XEvent`] objects.
            ///
            /// This method returns an instance of [`XEventBuilder`](crate::builders::XEventBuilder) which can be used to create [`XEvent`] objects.
            pub fn builder() -> XEventBuilder {
                XEventBuilder::new()
            }
        
}

impl Default for XEvent {
                     fn default() -> Self {
                         glib::object::Object::new::<Self>()
                     }
                 }

// rustdoc-stripper-ignore-next
        /// A [builder-pattern] type to construct [`XEvent`] objects.
        ///
        /// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct XEventBuilder {
            builder: glib::object::ObjectBuilder<'static, XEvent>,
        }

        impl XEventBuilder {
        fn new() -> Self {
            Self { builder: glib::object::Object::builder() }
        }

                            pub fn event_type(self, event_type: i32) -> Self {
                            Self { builder: self.builder.property("event-type", event_type), }
                        }

                            pub fn group(self, group: u32) -> Self {
                            Self { builder: self.builder.property("group", group), }
                        }

                            pub fn hardware_keycode(self, hardware_keycode: u32) -> Self {
                            Self { builder: self.builder.property("hardware-keycode", hardware_keycode), }
                        }

                            pub fn is_modifier(self, is_modifier: bool) -> Self {
                            Self { builder: self.builder.property("is-modifier", is_modifier), }
                        }

                            pub fn keyval(self, keyval: u32) -> Self {
                            Self { builder: self.builder.property("keyval", keyval), }
                        }

                            pub fn length(self, length: i32) -> Self {
                            Self { builder: self.builder.property("length", length), }
                        }

                            pub fn purpose(self, purpose: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("purpose", purpose.into()), }
                        }

                            pub fn root(self, root: u32) -> Self {
                            Self { builder: self.builder.property("root", root), }
                        }

                            pub fn same_screen(self, same_screen: bool) -> Self {
                            Self { builder: self.builder.property("same-screen", same_screen), }
                        }

                            pub fn send_event(self, send_event: i32) -> Self {
                            Self { builder: self.builder.property("send-event", send_event), }
                        }

                            pub fn serial(self, serial: libc::c_ulong) -> Self {
                            Self { builder: self.builder.property("serial", serial), }
                        }

                            pub fn state(self, state: u32) -> Self {
                            Self { builder: self.builder.property("state", state), }
                        }

                            pub fn string(self, string: impl Into<glib::GString>) -> Self {
                            Self { builder: self.builder.property("string", string.into()), }
                        }

                            pub fn subwindow(self, subwindow: u32) -> Self {
                            Self { builder: self.builder.property("subwindow", subwindow), }
                        }

                            pub fn time(self, time: u32) -> Self {
                            Self { builder: self.builder.property("time", time), }
                        }

                            pub fn window(self, window: u32) -> Self {
                            Self { builder: self.builder.property("window", window), }
                        }

                            pub fn x(self, x: i32) -> Self {
                            Self { builder: self.builder.property("x", x), }
                        }

                            pub fn x_root(self, x_root: i32) -> Self {
                            Self { builder: self.builder.property("x-root", x_root), }
                        }

                            pub fn y(self, y: i32) -> Self {
                            Self { builder: self.builder.property("y", y), }
                        }

                            pub fn y_root(self, y_root: i32) -> Self {
                            Self { builder: self.builder.property("y-root", y_root), }
                        }

    // rustdoc-stripper-ignore-next
    /// Build the [`XEvent`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> XEvent {
    self.builder.build() }
}

pub trait XEventExt: 'static {
    #[doc(alias = "ibus_x_event_get_event_type")]
    #[doc(alias = "get_event_type")]
    fn event_type(&self) -> XEventType;

    #[doc(alias = "ibus_x_event_get_group")]
    #[doc(alias = "get_group")]
    fn group(&self) -> u8;

    #[doc(alias = "ibus_x_event_get_hardware_keycode")]
    #[doc(alias = "get_hardware_keycode")]
    fn hardware_keycode(&self) -> u16;

    #[doc(alias = "ibus_x_event_get_is_modifier")]
    #[doc(alias = "get_is_modifier")]
    fn is_modifier(&self) -> bool;

    #[doc(alias = "ibus_x_event_get_keyval")]
    #[doc(alias = "get_keyval")]
    fn keyval(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_length")]
    #[doc(alias = "get_length")]
    fn length(&self) -> i32;

    #[doc(alias = "ibus_x_event_get_purpose")]
    #[doc(alias = "get_purpose")]
    fn purpose(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_x_event_get_root")]
    #[doc(alias = "get_root")]
    fn root(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_same_screen")]
    #[doc(alias = "get_same_screen")]
    fn is_same_screen(&self) -> bool;

    #[doc(alias = "ibus_x_event_get_send_event")]
    #[doc(alias = "get_send_event")]
    fn send_event(&self) -> i8;

    #[doc(alias = "ibus_x_event_get_serial")]
    #[doc(alias = "get_serial")]
    fn serial(&self) -> libc::c_ulong;

    #[doc(alias = "ibus_x_event_get_state")]
    #[doc(alias = "get_state")]
    fn state(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_string")]
    #[doc(alias = "get_string")]
    fn string(&self) -> Option<glib::GString>;

    #[doc(alias = "ibus_x_event_get_subwindow")]
    #[doc(alias = "get_subwindow")]
    fn subwindow(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_time")]
    #[doc(alias = "get_time")]
    fn time(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_version")]
    #[doc(alias = "get_version")]
    fn version(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_window")]
    #[doc(alias = "get_window")]
    fn window(&self) -> u32;

    #[doc(alias = "ibus_x_event_get_x")]
    #[doc(alias = "get_x")]
    fn x(&self) -> i32;

    #[doc(alias = "ibus_x_event_get_x_root")]
    #[doc(alias = "get_x_root")]
    fn x_root(&self) -> i32;

    #[doc(alias = "ibus_x_event_get_y")]
    #[doc(alias = "get_y")]
    fn y(&self) -> i32;

    #[doc(alias = "ibus_x_event_get_y_root")]
    #[doc(alias = "get_y_root")]
    fn y_root(&self) -> i32;

    #[doc(alias = "version")]
    fn connect_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<XEvent>> XEventExt for O {
    fn event_type(&self) -> XEventType {
        unsafe {
            from_glib(ffi::ibus_x_event_get_event_type(self.as_ref().to_glib_none().0))
        }
    }

    fn group(&self) -> u8 {
        unsafe {
            ffi::ibus_x_event_get_group(self.as_ref().to_glib_none().0)
        }
    }

    fn hardware_keycode(&self) -> u16 {
        unsafe {
            ffi::ibus_x_event_get_hardware_keycode(self.as_ref().to_glib_none().0)
        }
    }

    fn is_modifier(&self) -> bool {
        unsafe {
            from_glib(ffi::ibus_x_event_get_is_modifier(self.as_ref().to_glib_none().0))
        }
    }

    fn keyval(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_keyval(self.as_ref().to_glib_none().0)
        }
    }

    fn length(&self) -> i32 {
        unsafe {
            ffi::ibus_x_event_get_length(self.as_ref().to_glib_none().0)
        }
    }

    fn purpose(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_x_event_get_purpose(self.as_ref().to_glib_none().0))
        }
    }

    fn root(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_root(self.as_ref().to_glib_none().0)
        }
    }

    fn is_same_screen(&self) -> bool {
        unsafe {
            from_glib(ffi::ibus_x_event_get_same_screen(self.as_ref().to_glib_none().0))
        }
    }

    fn send_event(&self) -> i8 {
        unsafe {
            ffi::ibus_x_event_get_send_event(self.as_ref().to_glib_none().0)
        }
    }

    fn serial(&self) -> libc::c_ulong {
        unsafe {
            ffi::ibus_x_event_get_serial(self.as_ref().to_glib_none().0)
        }
    }

    fn state(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_state(self.as_ref().to_glib_none().0)
        }
    }

    fn string(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::ibus_x_event_get_string(self.as_ref().to_glib_none().0))
        }
    }

    fn subwindow(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_subwindow(self.as_ref().to_glib_none().0)
        }
    }

    fn time(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_time(self.as_ref().to_glib_none().0)
        }
    }

    fn version(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_version(self.as_ref().to_glib_none().0)
        }
    }

    fn window(&self) -> u32 {
        unsafe {
            ffi::ibus_x_event_get_window(self.as_ref().to_glib_none().0)
        }
    }

    fn x(&self) -> i32 {
        unsafe {
            ffi::ibus_x_event_get_x(self.as_ref().to_glib_none().0)
        }
    }

    fn x_root(&self) -> i32 {
        unsafe {
            ffi::ibus_x_event_get_x_root(self.as_ref().to_glib_none().0)
        }
    }

    fn y(&self) -> i32 {
        unsafe {
            ffi::ibus_x_event_get_y(self.as_ref().to_glib_none().0)
        }
    }

    fn y_root(&self) -> i32 {
        unsafe {
            ffi::ibus_x_event_get_y_root(self.as_ref().to_glib_none().0)
        }
    }

    fn connect_version_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_version_trampoline<P: IsA<XEvent>, F: Fn(&P) + 'static>(this: *mut ffi::IBusXEvent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(XEvent::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::version\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_version_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for XEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("XEvent")
    }
}
