// This file was generated by gir (https://github.com/gtk-rs/gir)
// from /usr/share/gir-1.0
// from ../gir-files
// DO NOT EDIT

use bitflags::{bitflags};
use glib::{translate::*,value::FromValue,value::ToValue,StaticType,Type};
use std::{fmt};

bitflags! {
    #[doc(alias = "IBusBusNameFlag")]
    pub struct BusNameFlag: u32 {
        #[doc(alias = "IBUS_BUS_NAME_FLAG_ALLOW_REPLACEMENT")]
        const ALLOW_REPLACEMENT = ffi::IBUS_BUS_NAME_FLAG_ALLOW_REPLACEMENT as _;
        #[doc(alias = "IBUS_BUS_NAME_FLAG_REPLACE_EXISTING")]
        const REPLACE_EXISTING = ffi::IBUS_BUS_NAME_FLAG_REPLACE_EXISTING as _;
        #[doc(alias = "IBUS_BUS_NAME_FLAG_DO_NOT_QUEUE")]
        const DO_NOT_QUEUE = ffi::IBUS_BUS_NAME_FLAG_DO_NOT_QUEUE as _;
    }
}

impl fmt::Display for BusNameFlag {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for BusNameFlag {
    type GlibType = ffi::IBusBusNameFlag;

    #[inline]
    fn into_glib(self) -> ffi::IBusBusNameFlag {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::IBusBusNameFlag> for BusNameFlag {
    #[inline]
    unsafe fn from_glib(value: ffi::IBusBusNameFlag) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for BusNameFlag {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::ibus_bus_name_flag_get_type()) }
    }
}

impl glib::HasParamSpec for BusNameFlag {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name| Self::ParamSpec::builder(name)
                }
}

impl glib::value::ValueType for BusNameFlag {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for BusNameFlag {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for BusNameFlag {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BusNameFlag> for glib::Value {
    #[inline]
    fn from(v: BusNameFlag) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "IBusCapabilite")]
    pub struct Capabilite: u32 {
        #[doc(alias = "IBUS_CAP_PREEDIT_TEXT")]
        const PREEDIT_TEXT = ffi::IBUS_CAP_PREEDIT_TEXT as _;
        #[doc(alias = "IBUS_CAP_AUXILIARY_TEXT")]
        const AUXILIARY_TEXT = ffi::IBUS_CAP_AUXILIARY_TEXT as _;
        #[doc(alias = "IBUS_CAP_LOOKUP_TABLE")]
        const LOOKUP_TABLE = ffi::IBUS_CAP_LOOKUP_TABLE as _;
        #[doc(alias = "IBUS_CAP_FOCUS")]
        const FOCUS = ffi::IBUS_CAP_FOCUS as _;
        #[doc(alias = "IBUS_CAP_PROPERTY")]
        const PROPERTY = ffi::IBUS_CAP_PROPERTY as _;
        #[doc(alias = "IBUS_CAP_SURROUNDING_TEXT")]
        const SURROUNDING_TEXT = ffi::IBUS_CAP_SURROUNDING_TEXT as _;
        #[doc(alias = "IBUS_CAP_OSK")]
        const OSK = ffi::IBUS_CAP_OSK as _;
        #[doc(alias = "IBUS_CAP_SYNC_PROCESS_KEY")]
        const SYNC_PROCESS_KEY = ffi::IBUS_CAP_SYNC_PROCESS_KEY as _;
    }
}

impl fmt::Display for Capabilite {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for Capabilite {
    type GlibType = ffi::IBusCapabilite;

    #[inline]
    fn into_glib(self) -> ffi::IBusCapabilite {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::IBusCapabilite> for Capabilite {
    #[inline]
    unsafe fn from_glib(value: ffi::IBusCapabilite) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for Capabilite {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::ibus_capabilite_get_type()) }
    }
}

impl glib::HasParamSpec for Capabilite {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name| Self::ParamSpec::builder(name)
                }
}

impl glib::value::ValueType for Capabilite {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for Capabilite {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for Capabilite {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Capabilite> for glib::Value {
    #[inline]
    fn from(v: Capabilite) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
    #[doc(alias = "IBusInputHints")]
    pub struct InputHints: u32 {
        #[doc(alias = "IBUS_INPUT_HINT_NONE")]
        const NONE = ffi::IBUS_INPUT_HINT_NONE as _;
        #[doc(alias = "IBUS_INPUT_HINT_SPELLCHECK")]
        const SPELLCHECK = ffi::IBUS_INPUT_HINT_SPELLCHECK as _;
        #[doc(alias = "IBUS_INPUT_HINT_NO_SPELLCHECK")]
        const NO_SPELLCHECK = ffi::IBUS_INPUT_HINT_NO_SPELLCHECK as _;
        #[doc(alias = "IBUS_INPUT_HINT_WORD_COMPLETION")]
        const WORD_COMPLETION = ffi::IBUS_INPUT_HINT_WORD_COMPLETION as _;
        #[doc(alias = "IBUS_INPUT_HINT_LOWERCASE")]
        const LOWERCASE = ffi::IBUS_INPUT_HINT_LOWERCASE as _;
        #[doc(alias = "IBUS_INPUT_HINT_UPPERCASE_CHARS")]
        const UPPERCASE_CHARS = ffi::IBUS_INPUT_HINT_UPPERCASE_CHARS as _;
        #[doc(alias = "IBUS_INPUT_HINT_UPPERCASE_WORDS")]
        const UPPERCASE_WORDS = ffi::IBUS_INPUT_HINT_UPPERCASE_WORDS as _;
        #[doc(alias = "IBUS_INPUT_HINT_UPPERCASE_SENTENCES")]
        const UPPERCASE_SENTENCES = ffi::IBUS_INPUT_HINT_UPPERCASE_SENTENCES as _;
        #[doc(alias = "IBUS_INPUT_HINT_INHIBIT_OSK")]
        const INHIBIT_OSK = ffi::IBUS_INPUT_HINT_INHIBIT_OSK as _;
        #[doc(alias = "IBUS_INPUT_HINT_VERTICAL_WRITING")]
        const VERTICAL_WRITING = ffi::IBUS_INPUT_HINT_VERTICAL_WRITING as _;
        #[doc(alias = "IBUS_INPUT_HINT_EMOJI")]
        const EMOJI = ffi::IBUS_INPUT_HINT_EMOJI as _;
        #[doc(alias = "IBUS_INPUT_HINT_NO_EMOJI")]
        const NO_EMOJI = ffi::IBUS_INPUT_HINT_NO_EMOJI as _;
        #[doc(alias = "IBUS_INPUT_HINT_PRIVATE")]
        const PRIVATE = ffi::IBUS_INPUT_HINT_PRIVATE as _;
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl fmt::Display for InputHints {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
#[doc(hidden)]
impl IntoGlib for InputHints {
    type GlibType = ffi::IBusInputHints;

    #[inline]
    fn into_glib(self) -> ffi::IBusInputHints {
        self.bits()
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
#[doc(hidden)]
impl FromGlib<ffi::IBusInputHints> for InputHints {
    #[inline]
    unsafe fn from_glib(value: ffi::IBusInputHints) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl StaticType for InputHints {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::ibus_input_hints_get_type()) }
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl glib::HasParamSpec for InputHints {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name| Self::ParamSpec::builder(name)
                }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl glib::value::ValueType for InputHints {
    type Type = Self;
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
unsafe impl<'a> FromValue<'a> for InputHints {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl ToValue for InputHints {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v1_5_4", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v1_5_4")))]
impl From<InputHints> for glib::Value {
    #[inline]
    fn from(v: InputHints) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "IBusModifierType")]
    pub struct ModifierType: u32 {
        #[doc(alias = "IBUS_SHIFT_MASK")]
        const SHIFT_MASK = ffi::IBUS_SHIFT_MASK as _;
        #[doc(alias = "IBUS_LOCK_MASK")]
        const LOCK_MASK = ffi::IBUS_LOCK_MASK as _;
        #[doc(alias = "IBUS_CONTROL_MASK")]
        const CONTROL_MASK = ffi::IBUS_CONTROL_MASK as _;
        #[doc(alias = "IBUS_MOD1_MASK")]
        const MOD1_MASK = ffi::IBUS_MOD1_MASK as _;
        #[doc(alias = "IBUS_MOD2_MASK")]
        const MOD2_MASK = ffi::IBUS_MOD2_MASK as _;
        #[doc(alias = "IBUS_MOD3_MASK")]
        const MOD3_MASK = ffi::IBUS_MOD3_MASK as _;
        #[doc(alias = "IBUS_MOD4_MASK")]
        const MOD4_MASK = ffi::IBUS_MOD4_MASK as _;
        #[doc(alias = "IBUS_MOD5_MASK")]
        const MOD5_MASK = ffi::IBUS_MOD5_MASK as _;
        #[doc(alias = "IBUS_BUTTON1_MASK")]
        const BUTTON1_MASK = ffi::IBUS_BUTTON1_MASK as _;
        #[doc(alias = "IBUS_BUTTON2_MASK")]
        const BUTTON2_MASK = ffi::IBUS_BUTTON2_MASK as _;
        #[doc(alias = "IBUS_BUTTON3_MASK")]
        const BUTTON3_MASK = ffi::IBUS_BUTTON3_MASK as _;
        #[doc(alias = "IBUS_BUTTON4_MASK")]
        const BUTTON4_MASK = ffi::IBUS_BUTTON4_MASK as _;
        #[doc(alias = "IBUS_BUTTON5_MASK")]
        const BUTTON5_MASK = ffi::IBUS_BUTTON5_MASK as _;
        #[doc(alias = "IBUS_HANDLED_MASK")]
        const HANDLED_MASK = ffi::IBUS_HANDLED_MASK as _;
        #[doc(alias = "IBUS_FORWARD_MASK")]
        const FORWARD_MASK = ffi::IBUS_FORWARD_MASK as _;
        #[doc(alias = "IBUS_IGNORED_MASK")]
        const IGNORED_MASK = ffi::IBUS_IGNORED_MASK as _;
        #[doc(alias = "IBUS_SUPER_MASK")]
        const SUPER_MASK = ffi::IBUS_SUPER_MASK as _;
        #[doc(alias = "IBUS_HYPER_MASK")]
        const HYPER_MASK = ffi::IBUS_HYPER_MASK as _;
        #[doc(alias = "IBUS_META_MASK")]
        const META_MASK = ffi::IBUS_META_MASK as _;
        #[doc(alias = "IBUS_RELEASE_MASK")]
        const RELEASE_MASK = ffi::IBUS_RELEASE_MASK as _;
        #[doc(alias = "IBUS_MODIFIER_MASK")]
        const MODIFIER_MASK = ffi::IBUS_MODIFIER_MASK as _;
    }
}

impl fmt::Display for ModifierType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ModifierType {
    type GlibType = ffi::IBusModifierType;

    #[inline]
    fn into_glib(self) -> ffi::IBusModifierType {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::IBusModifierType> for ModifierType {
    #[inline]
    unsafe fn from_glib(value: ffi::IBusModifierType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ModifierType {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::ibus_modifier_type_get_type()) }
    }
}

impl glib::HasParamSpec for ModifierType {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name| Self::ParamSpec::builder(name)
                }
}

impl glib::value::ValueType for ModifierType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ModifierType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ModifierType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ModifierType> for glib::Value {
    #[inline]
    fn from(v: ModifierType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

bitflags! {
    #[doc(alias = "IBusObjectFlags")]
    pub struct ObjectFlags: u32 {
        #[doc(alias = "IBUS_IN_DESTRUCTION")]
        const IN_DESTRUCTION = ffi::IBUS_IN_DESTRUCTION as _;
        #[doc(alias = "IBUS_DESTROYED")]
        const DESTROYED = ffi::IBUS_DESTROYED as _;
        #[doc(alias = "IBUS_RESERVED_1")]
        const RESERVED_1 = ffi::IBUS_RESERVED_1 as _;
        #[doc(alias = "IBUS_RESERVED_2")]
        const RESERVED_2 = ffi::IBUS_RESERVED_2 as _;
    }
}

impl fmt::Display for ObjectFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ObjectFlags {
    type GlibType = ffi::IBusObjectFlags;

    #[inline]
    fn into_glib(self) -> ffi::IBusObjectFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::IBusObjectFlags> for ObjectFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::IBusObjectFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ObjectFlags {
    #[inline]
    fn static_type() -> Type {
        unsafe { from_glib(ffi::ibus_object_flags_get_type()) }
    }
}

impl glib::HasParamSpec for ObjectFlags {
                type ParamSpec = glib::ParamSpecFlags;
                type SetValue = Self;
                type BuilderFn = fn(&str) -> glib::ParamSpecFlagsBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    |name| Self::ParamSpec::builder(name)
                }
}

impl glib::value::ValueType for ObjectFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ObjectFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ObjectFlags {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ObjectFlags> for glib::Value {
    #[inline]
    fn from(v: ObjectFlags) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

